#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdarg.h>
#include <errno.h>
#include <linux/limits.h>
#include <linux/usb/ch9.h>
#include <linux/usbdevice_fs.h>
#include <asm/byteorder.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <stdint.h>
#include <fcntl.h>
#include <sys/types.h>

#define USB_CDC_REQ_GET_LINE_CODING 0x21U
#define USB_CDC_REQ_SET_LINE_CODING 0x20U

#define COM_VID 0x0483
#define COM_PID 0x5740

#define SYSFS_DEVICE_PATH "/sys/bus/usb/devices"
#define USBFS_PATH "/dev/bus/usb"


/* silly fscanf wrapper that takes a path */
static int scanf_path(const char *path, const char* fmt, ...)
{
	int result;
	FILE *fd;
	va_list args;
	
	va_start(args, fmt);
	if((fd = fopen(path, "r")) == NULL)
		return 0;
	
	result = vfscanf(fd, fmt, args);
	fclose(fd);
	va_end(args);
	return result;
}


/* returns 0 on sucess, -1 on fail */
static int find_sysfs_dir(char *path, size_t pathlen, int vid, int pid)
{
	DIR *d;
	struct dirent *dir;
	char tmp_path[PATH_MAX];
	int found = -1;
	int tmp;
	
	if((d = opendir(SYSFS_DEVICE_PATH)) == NULL)
		return -1;
	
	while ((dir = readdir(d)) != NULL) {
		if (dir->d_name[0] == '.')
			continue;
		
		snprintf(tmp_path,
			sizeof(tmp_path),
			SYSFS_DEVICE_PATH "/%s/idVendor",
			dir->d_name);
		
		if (scanf_path(tmp_path, "%x", &tmp) != 1 || tmp != vid)
			continue;
		
		snprintf(tmp_path,
			sizeof(tmp_path),
			SYSFS_DEVICE_PATH "/%s/idProduct",
			dir->d_name);
		
		if (scanf_path(tmp_path, "%x", &tmp) != 1 || tmp != pid)
			continue;
		
		found = 0; // success!
		snprintf(path,
			pathlen,
			SYSFS_DEVICE_PATH "/%s",
			dir->d_name);
	}
	
	closedir(d);
	return found;
}




int get_device(int vid, int pid)
{
	char sysfs_dir[PATH_MAX];
	char tmp_path[PATH_MAX];
	int busnum, devnum;
	
	if (find_sysfs_dir(sysfs_dir, sizeof(sysfs_dir), vid, pid) < 0) {
		errno = ENXIO; // is this a suitable errno?
		return -1;
	}
	
	strncpy(tmp_path, sysfs_dir, sizeof(tmp_path));
	strncat(tmp_path, "/busnum", sizeof(tmp_path)-1);
	if (scanf_path(tmp_path, "%d", &busnum) != 1)
		return -1;
	
	strncpy(tmp_path, sysfs_dir, sizeof(tmp_path));
	strncat(tmp_path, "/devnum", sizeof(tmp_path)-1);
	if (scanf_path(tmp_path, "%d", &devnum) != 1)
		return -1;
	
	snprintf(tmp_path,
		sizeof(tmp_path),
		USBFS_PATH "/%03d/%03d",
		busnum,
		devnum);
	
	return open(tmp_path, O_RDWR);
}

int ctrl_transfer_unbounded_read(int fd, int length, char *buf_out)
{
    int buf_size = sizeof(struct usb_ctrlrequest) + length;
    uint8_t *buffer = calloc(1, buf_size);
    struct usbdevfs_urb *purb;
    
    struct usb_ctrlrequest *ctrl_req = (struct usb_ctrlrequest *) buffer;
    ctrl_req->bRequestType = USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_DEVICE;
    ctrl_req->bRequest = USB_CDC_REQ_GET_LINE_CODING;
    ctrl_req->wIndex = 0;
    ctrl_req->wLength = length;
    
    struct usbdevfs_urb urb = {
        .type = USBDEVFS_URB_TYPE_CONTROL,
        .endpoint = 0,
        .buffer = buffer,
        .buffer_length = buf_size,
        .usercontext = (void *) 0x1337,
    };
    
    if (ioctl(fd, USBDEVFS_SUBMITURB, &urb) < 0)
        return -1;
    
    if (ioctl(fd, USBDEVFS_REAPURB, &purb) < 0)
        return -2;

    memcpy(buf_out, buffer + sizeof(struct usb_ctrlrequest), length);
    free(buffer);

    return 0;
}

int ctrl_transfer_unbounded_write(int fd, int length, char *buf)
{
    int buf_size = sizeof(struct usb_ctrlrequest) + length;
    uint8_t *buffer = calloc(1, buf_size);
    struct usbdevfs_urb *purb;
    
    memcpy(buffer + sizeof(struct usb_ctrlrequest), buf, length);
            
    struct usb_ctrlrequest *ctrl_req = (struct usb_ctrlrequest *) buffer;
    ctrl_req->bRequestType = USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE;
    ctrl_req->bRequest = USB_CDC_REQ_SET_LINE_CODING;
    ctrl_req->wIndex = 0;
    ctrl_req->wLength = length;

    struct usbdevfs_urb urb = {
        .type = USBDEVFS_URB_TYPE_CONTROL,
        .endpoint = 0,
        .buffer = buffer,
        .buffer_length = buf_size,
        .usercontext = (void *) 0x1337,
    };

    if (ioctl(fd, USBDEVFS_SUBMITURB, &urb) < 0)
        return -1;
    
    if (ioctl(fd, USBDEVFS_REAPURB, &purb) < 0)
        return -2;
        
    free(buffer);

    return 0;
}

#define LENGTH 0xfff0

int main() {

	int usb_fd = get_device(COM_VID, COM_PID); //open("/dev/ttyACM0", O_WRONLY);// /dev/ttyACM0 get_device(COM_VID, COM_PID);
    printf("device id: %d\n", usb_fd);

    char *output = (char *)calloc(1, LENGTH);
    if (output == NULL) return -1;
    const int length = LENGTH;

    ctrl_transfer_unbounded_read(usb_fd, length, output);

    FILE *fp;
    fp = fopen("result.bin", "w");
    if (fp == NULL) return -1;
    fwrite(output, 1, LENGTH, fp);

    free(output);

    return 0;
}

